---
title: "inla-test"
author: "Dan Weinberger"
date: "1/3/2020"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  echo=F,
  comment = "#>",
  fig.height = 3,
  fig.width = 5,
  fig.align = "center", 
  dpi=300, 
	out.width="600px"
)
```

---

```{r setup_packages, include=FALSE, echo=TRUE}
#Install the package
#library(devtools)
#devtools::install_github('https://github.com/weinbergerlab/InterventionEvaluatR') 
library(knitr)
library(plyr)
library(InterventionEvaluatR)
library(rjags)
library(coda)
library(HDInterval)
library(lubridate)
library(pbapply)
library(parallel)
library(plyr)
library(ggbiplot)
library(htmlTable)
library(nFactors)
library(INLA)

library(bsts)

```

---
title: "Estimated change associated with the introduction of vaccine in South Africa"
---

---
## Important note
This Rmd file contains analyses of the data from S Africa. It uses a slightly different model (Poisson) than the one described in Kleynhans et al. To see those results, see the synthetic_control_run.R file

Local linear trend:
https://www.sciencedirect.com/science/article/pii/S0167947311003999?via%3Dihub

## Prepare the dataset
```{r viewdata}
   sa1<-read.csv('../Data/RSA.csv')

   #Filter covariates that have no variance
   sa.covars<-sa1[, -which(names(sa1) %in% c('Pneum','date','age')  )]
   sa.covars$index<-1:nrow(sa.covars)
   sa1.spl<-split(sa.covars, sa1$age)
   variance.vars<-lapply(sa1.spl, function(x) apply(x[1:123,], 2, var)  ) #look in pre-vax period
      for(i in 1:length(sa1.spl)){
     sa1.spl[[i]]<-sa1.spl[[i]][,-which(variance.vars[[i]]==0)]
   }
   sa.covars<-rbind.fill(sa1.spl) #cobine back together
   sa.covars<-sa.covars[order(sa.covars$index),]
   sa.covars$index<-NULL
   sa2<-cbind.data.frame(sa1[, which(names(sa1) %in% c('Pneum','date','age')  )], sa.covars)
   sa2$date<-as.Date(sa1$date, '%Y-%m-%d' ) 
   
   exclude_covar <- c('AllRes', 	'PI', 	'POth', 	'AllDiar', 	 	'Menin', 	'BactMenin', 	'Bact', 	'OtMed', 	'Mast',	'SeptArthr', "denom", "A20_B99_excl_bac", "A16", "A17", "A18", "A19", "R00_R09", "R10_R19", "R20_R39", "R40_R49", "R50_R69", "R70_R94", "R95_R99", "D50_D89")      

   sa2<-sa2[,-which(names(sa2) %in% exclude_covar)]
   
 
```


## Set parameters for analysis

Here we need to set a few parameters. We Use the evaluatr.init() function to specify the name of the dataset, the date at which the vaccine is introduced, the date at which we want to begin evaluating the vaccine (typically 1-2 year after vaccine introduction). We also provide some information on the dataset, sch as whether the data are monthly or quarterly (n_seasons), the variable names for the grouping variable, the date variable, the outcome variable, and the denominator variable (if any).

#Select which age group to analyze
```{r}
#age.select=unique(sa2$age)[6]
#age.select
```

```{r setup_data, echo=TRUE}

analysis <- evaluatr.init(
  country = "SAfrica", data = sa2,
  post_period_start = "2009-04-01", 
  eval_period_start = "2010-04-01", 
  eval_period_end = "2016-12-01", 
  n_seasons = 12, #This is monthly data, so select 12
  year_def = "cal_year", # we are in southern hemisphere, so aggregate results by calendar year (Jan-Dec)
  group_name = "age",  #Strata categry name
  date_name = "date", #Date variable name
  outcome_name = "Pneum", #Outcome variable name
  denom_name = "denom", #Denominator variable name
  set.burnN=5000,
  set.sampleN=10000
)
set.seed(1)
```


```{r}
source('inla_functions.R')
```

## Run INLA
```{r}
#install.packages("INLA", repos=c(getOption("repos"), INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
#age.select<-unique(sa2$age)[3]

model.variants<-c('full','time','time_no_offset')
#model.variants<-c('time')

ptm <- proc.time()
mods<-lapply(model.variants, run_inla_mod)
names(mods)<-model.variants
proc.time() - ptm
#RUns in 2.2 minutes/ 134 seconds
```

```{r}
#Runs whole thing in 142 seconds
ptm <- proc.time()
n_cores<-min((detectCores()-1), length(model.variants))
 cl <- makeCluster(n_cores)
  clusterEvalQ(cl, {
    library(INLA, quietly = TRUE)
    library(HDInterval, quietly = TRUE)
    library(lubridate, quietly = TRUE)

  })
  clusterExport(cl, c('run_inla_mod','inla_mods', 'sa2', 'analysis','model.variants'), environment())
  mod1<-pblapply(cl = cl, model.variants, FUN=run_inla_mod)
stopCluster(cl)
proc.time() - ptm

```


RR for evaluation period
```{r, fig.width=4, fig.height=4}

rr.ar1<-round(t(sapply(inla1,'[[', 'rr.hdi')),2)
rr.ar1.format<-paste(rr.ar1[,'50%'] , ' (', rr.ar1[,'lower'], ',', rr.ar1[,'upper'] ,')', sep='' )


htmlTable(cbind.data.frame('Age'=unique(sa2$age),'RR (AR1)'=rr.ar1.format ))

```


```{r, fig.width=8, fig.height=4}
rand.eff.t1<-sapply(inla1,'[[', 'rand.eff.t1', simplify='array')
#rand.eff.t2<-sapply(inla1,'[[', 'rand.eff.t2', simplify='array')

dates<-unique(sa2$date)
par(mfrow=c(1,1))
intro.index<-which(dates== analysis$post_period[1])
matplot(rand.eff.t1[,1:5,1], type='l')
abline(v=intro.index)
#matplot(rand.eff.t2[,1:5,1], type='l')
#abline(v=intro.index)
```

Observed vs expected

```{r, fig.width=8, fig.height=4}
obs.exp.plotfunc<-function(ar1,  obs, title){
   par(mfrow=c(1,1))
   plot.range<-range(c(ar1,obs))
  matplot(ar1 ,type='l', col='gray', lty=c(1,2,2), bty='l',main=title, ylim=plot.range)
  points(obs, pch=16, col=rgb(0,0,0, alpha=0.25))
  abline(h=1)

}

pred.ar1<-sapply(inla1,'[[', 'posterior.pred.hdi', simplify=F) 
obs<- sapply(inla1,'[[', 'obs.y', simplify=F)
for(i in 1:length(pred.ar1)){
obs.exp.plotfunc( ar1=pred.ar1[[i]],  obs=obs[[i]], title=unique(sa2$age)[i])
}

```

Random intercept
```{r, fig.width=6, fig.height=4}
rr.plotfunc<-function(ar1,  title){
   par(mfrow=c(1,1))
   plot.range<-range(c(ar1))
  matplot(ar1 ,type='l', col='gray', lty=c(1,2,2), bty='l',main=title, ylim=plot.range)
  abline(h=0)
  }
rand.eff.ar1<-sapply(inla1,'[[', "rand.eff.combined.q" , simplify='array')


for(i in 1:dim(rand.eff.ar1)[3]){
rr.plotfunc( ar1=rand.eff.ar1[,,i],  title=unique(sa2$age)[i])
}
```


FOR AR1 model compare the regression piece and AR1 piece side by side
```{r}
rr.plotfunc<-function(ar1, reg, title){
   par(mfrow=c(1,2))
   plot.range<-range(c(ar1,reg))
  matplot(ar1 ,type='l', col='gray', lty=c(1,2,2), bty='l',main=title, ylim=plot.range)
  abline(h=0)
  
  matplot(reg ,type='l', col='gray', lty=c(1,2,2), bty='l', ylim=plot.range)
  abline(h=0)
  }
rand.eff.ar1<-sapply(inla1,'[[', "rand.eff.combined.q" , simplify='array')
fixed.effect.piece<-sapply(inla1,'[[', "fixed.effect" , simplify=F)

for(i in 1:dim(rand.eff.ar1)[3]){
rr.plotfunc( ar1=rand.eff.ar1[,,i], reg=fixed.effect.piece[[i]], title=unique(sa2$age)[i])
}
```

```{r}
rho<-lapply(inla1,'[[', 'rho1')
rho<-do.call('rbind', rho)
rho<-cbind.data.frame(unique(sa2$age),rho  )
rho
```

Betas
```{r}
beta.ar1<-lapply(inla1,'[[', 'beta.posterior.hdi')
names(beta.ar1)<-unique(sa2$age)  
 

top.betas<-lapply(beta.ar1, function(x){
  month.rows<-grep('month',row.names(x))
  x1<- x[-month.rows,]
  ranks<- rank(-x1[,'beta.posterior.median'])
  y<-x1[ranks<=5,]
  y<-y[order(-y[,1]),]
  return(y)
})
top.betas
```