---
author: "Daniel Weinberger"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{PAHO mortality example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
params:
  sensitivity: TRUE
  crossval: FALSE
---
need to delete: impact_results$[[VARIANT]]$groups$`ec 2-23m A`$
predict.bsts reg.mean  beta.mat
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.height = 3,
  fig.width = 5,
  fig.align = "center", 
  dpi=300, 
	out.width="600px"
)

```

---

## Installing the package
Uncomment and run the following 3 lines of code to install the package. You will be prompted to manually select a number to indicate whether to update dependencies and which ones. 
```{r}
#install.packages('devtools') 
#library(devtools) 
#devtools::install_github('https://github.com/weinbergerlab/InterventionEvaluatR') 
```

```{r setup_packages, include=FALSE, echo=TRUE}
library(xtable)
library(knitr)
library(htmlTable)
library(InterventionEvaluatR)
library(coda)
library(HDInterval)
library(lubridate)
library(pbapply)
library(parallel)
library(rstanarm)
```


```{r, echo=F}
#Save the Ecuador mortality data as part of the package
# library(RCurl)
# script <- getURL("https://raw.githubusercontent.com/weinbergerlab/paho-pneumonia-mortality/master/Data/PAHO%20all%20age%20cuts_SubChapters.csv", ssl.verifypeer = FALSE)
# 
# paho1 <-read.csv(text=getURL("https://raw.githubusercontent.com/weinbergerlab/paho-pneumonia-mortality/master/Data/PAHO%20all%20age%20cuts_SubChapters.csv"),  header=T)
# ecuador_mortality<-paho1[paho1$age_group %in% c('ec 2-59m A','ec 2-23m A','ec 24-59m A'), ]
# ecuador_mortality$age_group<-factor(ecuador_mortality$age_group)
# save(ecuador_mortality, file='../data/ecuador_mortality.rda')
```

---
title: "Estimated change in mortality associated with the introduction of vaccine in Ecuador"
---
## Analysis goal
The goal for this analysis is to quantify changes in the rates of mortality due to pneumonia  following the introduction of PCV10 in Ecuador in **August 2010**. To do this, we will use data from the national mortality registry from Ecuador for the period from 2005-2016. We will learn how to analyze these time series data and how to interpret the results.

The main outcome of interest for the analysis will be to evaluate changes in **J12_J18_prim**, which is the number of deaths where J12-J18 is coded as the primary cause of death (In Ecuador, only a single cause of death is recorded). 

---
## View dataset
We are using a dataset that has 3 different age strata: 2-23 months, 24-59 months, and 2-59 months, combined. The dataset contains monthly time series for a number of different causes of death that are classified by ICD10 sub-chapter. The columns have counts per month of deaths for the causes indicated by the range of ICD10 codes indicated in the header name. 

Let's load the data, which are included with the package
```{r viewdata, include=TRUE}
    data(ecuador_mortality, package = "InterventionEvaluatR") #load the data
    head(ecuador_mortality[,1:5]) #View first few rows and columns
    ds<-ecuador_mortality
```

#Get rid of vars with no variation
```{r}
covars<-ds[,-c(1:4)]
ds.spl<-split(covars, ds$age_group)
ds.spl<-lapply( ds.spl,  function(x) {
  var1<-apply(x[1:67,],2,var)  
  x[,var1==0]<-NA
  return(x)
}
  )
ds.comb<-do.call('rbind.data.frame',ds.spl)
ds<-cbind.data.frame(ds[,c(1:4)], ds.comb)
```


Ensure your date variable is in an R date format. If your variable is in a character or factor format, you need to tell R the format. 
-- %m is a 2 digit month; %b is a month abbreviation (ie Jan, Feb)
-- %d is a 2 digit day (0-31), 
-- %Y is a 4 digit year (e.g. 2011), %y is a 2 digit year (e.g. 11).  
These codes are separated by a dash or slash or space. Modify the tryFormats script below if needed to match the format in your dataset
```{r}
ds$monthdate<-as.Date(ds$monthdate, tryFormats=c('%Y-%m-%d',
                                                    '%m-%d-%Y',
                                                    '%m/%d/%Y',
                                                    '%Y/%m/%d',
                                                    '%d/%m/%Y'
                                                    ) )
```

## Set parameters for analysis

Here we need to set a few parameters. We Use the evaluatr.init() function to specify the name of the dataset, the date at which the vaccine is introduced, the date at which we want to begin evaluating the vaccine (typically 1-2 year after vaccine introduction). We also provide some information on the dataset, sch as whether the data are monthly or quarterly (n_seasons), the variable names for the grouping variable, the date variable, the outcome variable, and the denominator variable (if any). You can also set the number of interations for the MCMC. the default is to use a burn-in period of 5000 iterations and to sample 10,000 iterations afterthe burn in. This is a decent place to start. After evaluating model convergence (see below), you might want to increase the burn-in period.

```{r setup_data, echo=TRUE}

analysis <- evaluatr.init(
  country = "Ecuador", data = ds,
  post_period_start = "2010-08-01", #First 'post-intervention' month is Jan 2012
  eval_period_start = "2011-08-01", #We ignore first 12 month of data to allow for vaccine ramp up
  eval_period_end = "2015-12-01", #The evaluation period lasts 2 years
  n_seasons = 12, #This is monthly data, so select 12
  year_def = "cal_year", # we are in southern hemisphere, so aggregate results by calendar year (Jan-Dec)
  group_name = "age_group",  #Strata categry name
  date_name = "monthdate", #Date variable name
  outcome_name = "J12_J18_prim", #Outcome variable name
  denom_name = "acm_noj_prim" , #Denominator variable name
  log.covars=TRUE, #log-transform the covariates
  set.burnN=5000,
  set.sampleN=10000
)
set.seed(1)
```

### Sort data by age group and month
```{r}
    ds<-ds[order(ds[, analysis$group_name], ds[,analysis$date_name]),] #Sort data by age group and month
```


##Horseshoe prior
```{r}

call.jags.mod<-function(ds.in){  
  exclude.cols<-c(analysis$group_name, analysis$outcome_name, analysis$date_name)
  x<-ds.in[,-which(names(ds.in) %in% exclude.cols)]
    
  #Filter columsn with 0 variations in the covariate in the pre-vax period
  x.var<-apply(x,2, function(xx) var(xx[ds.in[,analysis$date_name]<analysis$post_period[1]] ))  
  x<-x[,x.var>0] 
  
  x.scale<-apply(x,2, function(z) scale(log(z+0.5))) 
  y<-ds.in[,analysis$outcome_name] 
  ds2<-cbind.data.frame(y, x.scale) 
  names(ds2)<-c(analysis$outcome_name,names(x)) 
  ds2.pre<-ds2[ds.in[,analysis$date_name]<analysis$post_period[1] ,] 
  ds3<-ds2 
  ds3[,analysis$outcome_name][ds.in[,analysis$date_name]>=analysis$post_period[1]]<-NA 
  months<-month(ds.in[,analysis$date_name]) 
  month.mat<-dummies::dummy(months) 
  month.mat<-month.mat[,-1]
  month.mat<-cbind(rep(1,nrow(month.mat)), month.mat) #add intercept
  month.mat.pre<- month.mat[ds.in[,analysis$date_name]<analysis$post_period[1] ,]
  
  mod.txt<- source('../jags/Non_spatial-Non_lagged-AR1.txt')
  mod1<-nonspace_nonlag(burnin=15000, 
                        samples=10000,
                        thin=1,
                        chains=1,
                        regularize=TRUE, 
                        dic=FALSE,
                        n_full=length(ds3[,analysis$outcome_name]),
                        n_modeling=nrow(ds2.pre),
                        y_modeling=ds3[,analysis$outcome_name],
                        offset=rep(0, length(y)) ,
                        z=month.mat,  #parameters not being shrunk
                        x=ds3[,-1]
                        )
  
  posterior_samples.all<-do.call(rbind,mod1[[1]])
  post_means<-apply(posterior_samples.all, 2, median)
  sample.labs<-names(post_means)
  ci<-t(hdi(posterior_samples.all, credMass = 0.95))
  row.names(ci)<-sample.labs
  names(post_means)<-sample.labs
  post.combo<-cbind(post_means,ci)
  
  post.combo.y<-post.combo[grep('Y_pred', dimnames(post.combo)[[1]]),]
  post.combo.beta<-cbind.data.frame(post.combo[grep('beta', dimnames(post.combo)[[1]]),],dimnames(x)[[2]])
  # plot(y=1:nrow(post.combo.beta), x=post.combo.beta[,'post_means'], xlim=range(post.combo.beta[,1:3]), bty='l')
  # arrows(y0=1:nrow(post.combo.beta) ,x0=post.combo.beta[,2], x1=post.combo.beta[,3], length=0)
  # abline(v=0, col='gray', lty=2)
  # text(y=1:nrow(post.combo.beta), x=post.combo.beta[,'post_means']+0.1,dimnames(x)[[2]] , col='gray')
  
  #plot for post-vax period
  # matplot(post.combo.y, type='l')
  #  points(ds1$sALRI[(nrow(ds2.pre)+1):nrow(ds1)])
  # 
    log.rr.pointwise<- log((ds.in[(nrow(ds2.pre)+1):nrow(ds.in),analysis$outcome_name]+0.5)/(post.combo.y+0.5))
   # matplot(log.rr, type='l', col='gray', lty=c(2,1,2))
   # abline(h=0, col='red')
   
   length.rollout<-round(as.numeric((analysis$eval_period[1]-analysis$post_period[1]  )/30.3))
   post.samples<-posterior_samples.all[,-c(1:length.rollout)]
   post.samples.y<- post.samples[,grep('Y_pred', dimnames(post.samples)[[2]])]
   post.samples.sum<-apply(post.samples,1,sum)
   obs.post.sum<- sum(ds2[,analysis$outcome_name][ds.in[,analysis$date_name]>=analysis$post_period[1]][-c(1:length.rollout)])
   rr.agg<-obs.post.sum/post.samples.sum
   rr.q<-quantile(rr.agg, probs=c(0.025, 0.5, 0.975))
   output.list<-list('rr.samples'=rr.agg,'rr.q'=rr.q,'log.rr.pointwise.q'=log.rr.pointwise,'betas'=post.combo.beta,'rr.agg.iter'=rr.agg)
}

```

```{r}
n_cores<-3
ds.age.spl<-split(ds, ds$age_group)
  cl <- makeCluster(n_cores)
  clusterEvalQ(cl, {
    library(lubridate, quietly = TRUE)
    library(HDInterval, quietly = TRUE)
  })
  clusterExport(cl, c('call.jags.mod','analysis'), environment())
  
  mod1<-pblapply(cl = cl,X=ds.age.spl,FUN=call.jags.mod)
stopCluster(cl)

rr.summary<-t(sapply(mod1, '[[', 'rr.q'))
rr.pointwisesummary<-sapply(mod1, '[[', 'log.rr.pointwise.q',simplify='array')

betas<-sapply(mod1, '[[', 'betas',simplify=F)

betas<-lapply(betas, function(x) x[order(x$post_means),])

rr.samples<-sapply(mod1, '[[', 'rr.samples',simplify='array')

```





```{r}
rr.summary
```


```{r}
matplot(exp(rr.pointwisesummary[,,'ec 2-59m A']), type='l', col='gray', lty=c(1,3,3))
abline(h=1, lty=3)
```


```{r}
beta1<-betas[["ec 2-59m A"]]
beta1<-beta1[order(-beta1$post_means),]
beta1
```

```{r}
plot(rr.samples[,1], type='l')
```

TRY IN STAN,
```{r}
ds.spl<-split(ds, ds$age_group)

ds.select<-ds.spl[["ec 2-59m A" ]]
covars<-ds.select[,-c(1:3)]
complete.covars<- apply(covars,2,function(x) sum(is.na(x))) ==0 
covars<-covars[,complete.covars]
covars.scale<-apply(covars,2, function(z) scale(log(z+0.5))) 
outcome.pre<- ds.select$J12_J18_prim
outcome.pre[ds.select$monthdate>=analysis$intervention_date] <-NA

ds.stan<-cbind.data.frame(outcome.pre, covars.scale)
ds.stan.pre<-ds.stan[!is.na(ds.stan$outcome.pre),]

D<-ncol(covars)
n.covars<-ncol(covars)
p0=10  #prior expectation of model size
n=length(outcome.pre[!is.na(outcome.pre)])
sigma <-  sqrt(mean (outcome.pre, na.rm=TRUE )) # pseudo sigma mean=variance for poisson
tau0 <- p0 /( D - p0 ) * sigma / sqrt (n)
CHAINS=4
CORES=7
SEED=123
```

```{r}
stan_glm.mod<- stan_glm(outcome.pre~.,
                              data = ds.stan.pre, family = poisson()   ,
                              prior = hs(global_scale=tau0, df =1 , global_df =1) ,  
                          # prior = hs() ,  
                              chains = CHAINS, cores = CORES, seed = SEED ,iter=2000, adapt_delta=0.999)
```


#launch_shinystan(stan_glm.mod)
```{r}
preds  <-  t(posterior_predict(stan_glm.mod, newdata=ds.stan[,-1]))
preds.q<-t(apply(preds,1,quantile, probs=c(0.025,0.5,0.975)))
matplot(preds.q, type='l', col='gray', lty=c(2,1,2), ylim=c(0,max(preds.q)*1.05))
points(ds.stan$outcome.pre)

```

```{r}
summary(stan_glm.mod)
```

rr STAN
```{r}
 
post.indices<-which( ds.select$monthdate>= analysis$eval_period[[1]] & ds.select$monthdate<=analysis$eval_period[2] )
   
preds.post<-apply(preds[post.indices,],2,sum)
obs.post<-sum(ds.select$J12_J18_prim[post.indices])
rr.post<-obs.post/preds.post
plot(rr.post, type='l')
```

